<?php
namespace Codeception\Lib\Generator;

use Codeception\Codecept;
use Codeception\Configuration;
use Codeception\Lib\Di;
use Codeception\Lib\ModuleContainer;
use Codeception\Util\ReflectionHelper;
use Codeception\Util\Template;
use phpDocumentor\Reflection\DocBlock\Tags\TagWithType;
use phpDocumentor\Reflection\DocBlockFactory;
use phpDocumentor\Reflection\Type;
use phpDocumentor\Reflection\Types\AggregatedType;
use phpDocumentor\Reflection\Types\Object_;

class Actions
{

    protected $template = <<<EOF
<?php  //[STAMP] {{hash}}
namespace {{namespace}}_generated;

// This class was automatically generated by build task
// You should not change it manually as it will be overwritten on next build
// @codingStandardsIgnoreFile

{{imports}}

trait {{name}}Actions
{
    /**
     * @return \Codeception\Scenario
     */
    abstract protected function getScenario();

    {{methods}}
}

EOF;

    protected $methodTemplate = <<<EOF

    /**
     * [!] Method is generated. Documentation taken from corresponding module.
     *
     {{doc}}
     * @see \{{module}}::{{method}}()
     */
    public function {{action}}({{params}}){{return_type}} {
        {{return}}\$this->getScenario()->runStep(new \Codeception\Step\{{step}}('{{method}}', func_get_args()));
    }
EOF;

    protected $name;
    protected $settings;
    protected $modules = [];
    protected $actions;
    protected $imports = [];
    protected $numMethods = 0;

    /**
     * @var array GeneratedStep[]
     */
    protected $generatedSteps = [];
    /** @var \phpDocumentor\Reflection\DocBlockFactory */
    protected $docBlockFactory;

    public function __construct($settings)
    {
        $this->name = $settings['actor'];
        $this->settings = $settings;
        $this->di = new Di();
        $modules = Configuration::modules($this->settings);
        $this->moduleContainer = new ModuleContainer($this->di, $settings);
        foreach ($modules as $moduleName) {
            $this->moduleContainer->create($moduleName);
        }
        $this->modules = $this->moduleContainer->all();
        $this->actions = $this->moduleContainer->getActions();

        $this->generatedSteps = (array) $settings['step_decorators'];
        $this->docBlockFactory = DocBlockFactory::createInstance();
    }


    public function produce()
    {
        $namespace = rtrim($this->settings['namespace'], '\\');

        $methods = [];
        $code = [];
        foreach ($this->actions as $action => $moduleName) {
            if (in_array($action, $methods)) {
                continue;
            }
            $class = new \ReflectionClass($this->modules[$moduleName]);
            $method = $class->getMethod($action);
            $code[] = $this->addMethod($method);
            $this->checkTagsForImports($method);
            $methods[] = $action;
            $this->numMethods++;
        }

        $this->imports = array_unique($this->imports);
        $this->imports = array_diff($this->imports, ['object']); // do not add "object" to the use statements
        $importStatements = array_map(static function ($item){
            return "use $item;\n";
        }, $this->imports);

        return (new Template($this->template))
            ->place('namespace', $namespace ? $namespace . '\\' : '')
            ->place('hash', self::genHash($this->modules, $this->settings))
            ->place('name', $this->name)
            ->place('methods', implode("\n\n ", $code))
            ->place('imports', implode($importStatements))
            ->produce();
    }

    /**
     * Look at all tags which can have a type and check if they need an use statement.
     *
     * @param \ReflectionMethod $method
     */
    protected function checkTagsForImports(\ReflectionMethod $method)
    {
        $string = $method->getDocComment();
        if (!empty($string)) {
            foreach ($this->docBlockFactory->create($string)->getTags() as $tag) {
                if ($tag instanceof TagWithType) {
                    // skip this tag if it is typed but no type is specified, like with `@param $parameter1`
                    if ($tag->getType() === null) {
                        continue;
                    }
                    $this->inspectTypeDefinition($tag->getType(), $method);
                }
            }
        }
    }

    /**
     * Check the type of the annotation and add the necessary imports to the $imports property.
     *
     * @param \phpDocumentor\Reflection\Type $type
     * @param \ReflectionMethod              $method
     */
    protected function inspectTypeDefinition(Type $type, \ReflectionMethod $method)
    {
        // does it contain more than one type? e.g. "@return string|mixed"
        if ($type instanceof AggregatedType) {
            foreach ($type as $innerType) {
                $this->inspectTypeDefinition($innerType, $method);
            }
        } elseif ($type instanceof Object_) {
            // only tags of type Object_ are relevant as those might contain a FQN

            $fqsen = $type->getFqsen();
            if ($fqsen === null) {
                // skip objects which don't have a FQSEN
                return;
            }

            $strType = (string)$fqsen;

            if ($strType === "\\{$fqsen->getName()}") {
                // The FQN indicates, the class is in the root namespace. Look into the file and check if the library
                // not mistakenly assumed an imported type as a class in the root namespace.
                $import = $this->getImportForName($method->getFileName(), $strType);
                if ($import === null) {
                    // there was no use statement, so we can safely say that the $strType indeed refers to a class
                    // in the root namespace
                    $this->imports[] = $strType;
                } else {
                    $this->imports[] = $import;
                }
            }
        }
    }

    /**
     * Read the file at $filePath and look for an use statement for the given $className
     *
     * @param string $filePath  File to read
     * @param string $className Class name to look for
     * @return string|null string if an use statement was found; null otherwise
     */
    protected function getImportForName($filePath, $className)
    {
        if (!is_readable($filePath)) {
            return null;
        }
        $lines = file($filePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
        foreach ($lines as $line) {
            // does the line start with a "class" keyword? If yes, there will be no other imports, stop the loop
            if (strpos($line, 'class') === 0) {
                break;
            }

            // does the line start with use? If not, look at the next
            if (strpos($line, 'use') !== 0) {
                continue;
            }
            // does the line contain the requested type name? If not, continue the loop
            if (strpos($line, $className) === false) {
                continue;
            }
            // remove the trailing semicolon
            $line = trim($line, ";");

            $words = explode(' ', $line);
            array_shift($words); // remove the "use" keyword

            if (count($words) === 1) {
                // only one word remained, that is the imported FQN
                return $words[0];
            }
            // multiple words remained, seems like it was imported with an alias. Return with alias and hope it does
            // not clash with a different alias
            return implode(' ', $words);
        }
        return null;
    }

    protected function addMethod(\ReflectionMethod $refMethod)
    {
        $class = $refMethod->getDeclaringClass();
        $params = $this->getParamsString($refMethod);
        $module = $class->getName();

        $body = '';
        $doc = $this->addDoc($class, $refMethod);
        $doc = str_replace('/**', '', $doc);
        $doc = trim(str_replace('*/', '', $doc));
        if (!$doc) {
            $doc = "*";
        }
        $returnType = $this->createReturnTypeHint($refMethod);

        $methodTemplate = (new Template($this->methodTemplate))
            ->place('module', $module)
            ->place('method', $refMethod->name)
            ->place('return_type', $returnType)
            ->place('return', $returnType === ': void' ? '' : 'return ')
            ->place('params', $params);

        if (0 === strpos($refMethod->name, 'see')) {
            $type = 'Assertion';
        } elseif (0 === strpos($refMethod->name, 'am')) {
            $type = 'Condition';
        } else {
            $type = 'Action';
        }

        $body .= $methodTemplate
            ->place('doc', $doc)
            ->place('action', $refMethod->name)
            ->place('step', $type)
            ->produce();

        // add auto generated steps
        foreach (array_unique($this->generatedSteps) as $generator) {
            if (!is_callable([$generator, 'getTemplate'])) {
                throw new \Exception("Wrong configuration for generated steps. $generator doesn't implement \Codeception\Step\GeneratedStep interface");
            }
            $template = call_user_func([$generator, 'getTemplate'], clone $methodTemplate);
            if ($template) {
                $body .= $template->produce();
            }
        }

        return $body;
    }

    /**
     * @param \ReflectionMethod $refMethod
     * @return array
     */
    protected function getParamsString(\ReflectionMethod $refMethod)
    {
        $params = [];
        foreach ($refMethod->getParameters() as $param) {
            $type = '';
            if (PHP_VERSION_ID >= 70000) {
                $reflectionType = $param->getType();
                if ($reflectionType !== null) {
                    $type = $this->stringifyType($reflectionType) . ' ';
                }
            }
            if ($param->isOptional()) {
                $params[] = $type . '$' . $param->name . ' = ' . ReflectionHelper::getDefaultValue($param);
            } else {
                $params[] = $type . '$' . $param->name;
            }
        }
        return implode(', ', $params);
    }

    /**
     * @param \ReflectionClass $class
     * @param \ReflectionMethod $refMethod
     * @return string
     */
    protected function addDoc(\ReflectionClass $class, \ReflectionMethod $refMethod)
    {
        $doc = $refMethod->getDocComment();

        if (!$doc) {
            $interfaces = $class->getInterfaces();
            foreach ($interfaces as $interface) {
                $i = new \ReflectionClass($interface->name);
                if ($i->hasMethod($refMethod->name)) {
                    $doc = $i->getMethod($refMethod->name)->getDocComment();
                    break;
                }
            }
        }

        if (!$doc and $class->getParentClass()) {
            $parent = new \ReflectionClass($class->getParentClass()->name);
            if ($parent->hasMethod($refMethod->name)) {
                $doc = $parent->getMethod($refMethod->name)->getDocComment();
                return $doc;
            }
            return $doc;
        }
        return $doc;
    }

    public static function genHash($modules, $settings)
    {
        $actions = [];
        foreach ($modules as $moduleName => $module) {
            $actions[$moduleName] = get_class_methods(get_class($module));
        }

        return md5(Codecept::VERSION . serialize($actions) . serialize($settings['modules']) . implode(',', (array) $settings['step_decorators']));
    }

    public function getNumMethods()
    {
        return $this->numMethods;
    }

    private function createReturnTypeHint(\ReflectionMethod $refMethod)
    {
        if (PHP_VERSION_ID < 70000) {
            return '';
        }

        $returnType = $refMethod->getReturnType();

        if ($returnType === null) {
            return '';
        }

        return ': ' . $this->stringifyType($returnType);
    }

    /**
     * @param \ReflectionType $type
     * @return string
     */
    private function stringifyType(\ReflectionType $type)
    {
        if ($type instanceof \ReflectionUnionType) {
            $types = $type->getTypes();
            return implode('|', $types);
        }

        if (PHP_VERSION_ID < 70100) {
            $returnTypeString = (string)$type;
        } else {
            $returnTypeString = $type->getName();
        }
        return sprintf(
            '%s%s%s',
            (PHP_VERSION_ID >= 70100 && $type->allowsNull()) ? '?' : '',
            $type->isBuiltin() ? '' : '\\',
            $returnTypeString
        );
    }
}
